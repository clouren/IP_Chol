Source/IP_check_solution.c:            for (p = A->p[i]; p < A->p[i + 1]; p++)
Source/IP_check_solution.c:                OK(SLIP_mpq_set_z(temp, A->x.mpz[p]));
Source/IP_check_solution.c:                OK(SLIP_mpq_add(SLIP_2D(b2, A->i[p], j, mpq),
Source/IP_check_solution.c:                                        SLIP_2D(b2, A->i[p], j, mpq),temp));
Source/IP_Chol_counts.c:    m = A->m ; n = A->n ;
Source/IP_Chol_counts.c:            for (p = A->p [J] ; p < A->p [J+1] ; p++)
Source/IP_Chol_counts.c:                i = A->i [p] ;
Source/IP_Chol_ereach.c:    top = n = A->n ; 
Source/IP_Chol_ereach.c:    for (p = A->p [k] ; p < A->p [k+1] ; p++)
Source/IP_Chol_ereach.c:        i = A->i [p] ;                /* A(i,k) is nonzero */
Source/IP_Chol_etree.c:    m = A->m ; n = A->n ;
Source/IP_Chol_etree.c:        for (p = A->p [k] ; p < A->p [k+1] ; p++)
Source/IP_Chol_etree.c:            i = A->i [p] ;
Source/IP_Chol_permute_A.c:    int64_t nz = 0, j, n = A->n;
Source/IP_Chol_permute_A.c:    SLIP_matrix_allocate(&A2, SLIP_CSC, SLIP_MPZ, n, n, A->p[A->n], false, true, NULL);
Source/IP_Chol_permute_A.c:    OK(SLIP_mpq_set(A2->scale, A->scale));
Source/IP_Chol_permute_A.c:        for (int64_t t = A->p [j] ; t < A->p [j+1] ; t++)
Source/IP_Chol_permute_A.c:            OK(SLIP_mpz_set(A2->x.mpz[nz], A->x.mpz[t]));  // row i of A is row pinv[i] of C 
Source/IP_Chol_permute_A.c:            A2->i [nz++] = pinv [A->i [t]];
Source/IP_determine_symmetry.c:    for (j = 0; j < A->nz; j++)
Source/IP_determine_symmetry.c:        if (T->i[j] != A->i[j])
Source/IP_determine_symmetry.c:    for (j = 0; j <= A->n; j++)
Source/IP_determine_symmetry.c:        if (T->p[j] != A->p[j])
Source/IP_determine_symmetry.c:        for (j = 0; j < A->nz; j++)
Source/IP_determine_symmetry.c:            SLIP_mpz_cmp(&r, A->x.mpz[j], T->x.mpz[j]);
Source/IP_Left_Chol_Factor.c:    int64_t  n = A->n, top, i, j, k, col, loc, lnz = 0, unz = 0, pivot, jnew;
Source/IP_Left_Chol_Factor.c:    n = A->n;
Source/IP_Left_Chol_triangular_solve.c:    n = A->n;                                // Size of matrix and the dense vectors
Source/IP_Left_Chol_triangular_solve.c:    for (i = A->p[k]; i < A->p[k+1]; i++)
Source/IP_Left_Chol_triangular_solve.c:        if ( A->i[i] >= k)
Source/IP_Left_Chol_triangular_solve.c:            OK(SLIP_mpz_set(x->x.mpz[A->i[i]], A->x.mpz[i]));
Source/IP_Pre_Left_Factor.c:    int64_t  top, k, i, j, jnew, n = A->n;
Source/IP_Solve.c:    // set the scalint64_t*g factor scale = A->scale / b->scale
Source/IP_Solve.c:    SLIP_CHECK( SLIP_mpq_div(scale, A->scale, b->scale));
Source/IP_transpose.c:    SLIP_matrix_allocate(&C, SLIP_CSC, SLIP_MPZ, A->n, A->m, A->p[A->n], false, true, NULL);
Source/IP_transpose.c:    m = A->m ; n = A->n ; 
Source/IP_transpose.c:    for (p = 0 ; p < A->p [n] ; p++) w [A->i [p]]++ ;       /* row counts */
Source/IP_transpose.c:        for (p = A->p [j] ; p < A->p [j+1] ; p++)
Source/IP_transpose.c:            q = w [A->i [p]]++;
Source/IP_transpose.c:            OK(SLIP_mpz_set(C->x.mpz[q], A->x.mpz[p]));
Source/IP_transpose.c:    C->p[m] = A->p[n];
Source/IP_tripread_double.c:        &(A->i[0]), &(A->j[0]), &(A->x.fp64[0])) ;
Source/IP_tripread_double.c:    A->i[0] -= 1;
Source/IP_tripread_double.c:    A->j[0] -= 1;
Source/IP_tripread_double.c:            &(A->i[k]), &(A->j[k]), &(A->x.fp64[k]));
Source/IP_tripread_double.c:        A->i[k] -= 1;
Source/IP_tripread_double.c:        A->j[k] -= 1;
Source/IP_tripread_double.c:    A->nz = nz;
Source/IP_Up_Chol_Factor.c:    int64_t n = A->n, top, i, j, col, loc, lnz = 0, unz = 0, pivot, jnew, k;
Source/IP_Up_Chol_triangular_solve.c:    int64_t j, jnew, i, inew, p, m, top, n = A->n, col;
Source/IP_Up_Chol_triangular_solve.c:    for (i = A->p[k]; i < A->p[k+1]; i++)
Source/IP_Up_Chol_triangular_solve.c:        if (A->i[i] <= k)
Source/IP_Up_Chol_triangular_solve.c:            OK(SLIP_mpz_set(x->x.mpz[A->i[i]], A->x.mpz[i]));
